/*************************************************************************
Title:    game_console Template
Initial Author:   David Jahshan
Extended by : (Shiyu Zhang) (683557)
Software: AVR-GCC 
Hardware: ATMEGA16 @ 8Mhz 

DESCRIPTION:
	Main and functions for Meme Console basic sample code

*************************************************************************/

#include "game_console.h"


//initialise pins for buttons
void button_init(void)
{	

	UP_BUTTON_DIR(IN);
	UP_BUTTON_PULL(ON);

	DOWN_BUTTON_DIR(IN);
	DOWN_BUTTON_PULL(ON);

	LEFT_BUTTON_DIR(IN);
	LEFT_BUTTON_PULL(ON);

	RIGHT_BUTTON_DIR(IN);
	RIGHT_BUTTON_PULL(ON);

	A_BUTTON_DIR(IN);
	A_BUTTON_PULL(ON);

	B_BUTTON_DIR(IN);
	B_BUTTON_PULL(ON);

}

void PWN_init(void)
{

	LCD_BACKLIGHT_DIR(OUT); //direction of the port
	//need to modify TCCR0:Timer control register
	//MODE P83
	//WGM0(1:0):11: Fast PWM mode
	//COM0(1:0):11: set register OC0 to compare match, INVERTED MODE if 0
	//CS0(1:0)<-:01: Clock select
	TCCR0 = (1 << WGM00) | (1 << WGM01) |(1 << COM01) | (1 << COM00) |  (1 << CS01);

	//Output compare register0, waveform is generated by comparing time value
	//with TCNT P85
	OCR0 = BOTTOM; //set it 100% duty cycle
}


void PWM_INTR(void)
{
	if (A_BUTTON)
	{
		//by increasing the register value we can chnage the output square wave duty cycle
		if (OCR0 + INCREMENT >= BOTTOM)
		{
			OCR0 += INCREMENT;
		}
		else
		{
			OCR0 = TOP;
		}
		_delay_ms(120);
	}
}

void SPI_Init(void)
{
	//SPE: spi enable
	//MASTR: master mode
	//SPR0: TBL 58

	SPCR |= _BV(SPE) | _BV(MSTR) | _BV(SPR0); //Set SPI enable, Master Mode,SCK frequency(fosc/16)
}

unsigned char SPI_Transmit(unsigned char Tx_Data)
{
	SPDR = Tx_Data;//write the data to the spi tunnel
	//The SPIF Flag in SPSR is set, and if the SPI interrupt is enabled, and the I-bit in SREG is
     //set, the interrupt routine will be executed.
	while (!(SPSR & _BV(SPIF))); //Wait Master data transmission finishes
	return (SPDR);
}

void LCD_Command(unsigned char command)
{
	LCD_CS(LOW); //Set LCD_CS enable
	LCD_CD(CMD); //Set LCD_CD command enable
	SPI_Transmit(command);
	LCD_CS(HIGH);
}

void LCD_Data(unsigned char data)
{
	LCD_CS(LOW); //Set LCD_CS enable
	LCD_CD(DAT); //Set LCD_CD data enable
	SPI_Transmit(data);
	LCD_CS(HIGH);
}

void LCD_Init(void)
{
	LCD_Command(DISPLAY_ST);		 //Display start line 0
	LCD_Command(SEG_REVERSE);		 //SEG reverse
	LCD_Command(NORMAL_COM);		 //Normal COM0-COM63
	LCD_Command(DIS_PIXELS_ON);		 //Disable all pixels on
	LCD_Command(DIS_INVERSE_OFF);	//Display inverse off
	LCD_Command(LCD_BIAS_RATIO);	 //Set LCD Bias Ratio:1/9
	LCD_Command(POWER_CONTROL);		 //Set power control: booster on, voltage regulator on and voltage follower on
	LCD_Command(LCD_RESISTOR_RATIO); //Set VLCD resistor ratio
	LCD_Command(SET_ELECTRONIC_VOLUME1);
	LCD_Command(SET_ELECTRONIC_VOLUME2); //Set Electronic Volume:16
	LCD_Command(SET_ADVANCED_PROGRAM_CONTROL0);
	LCD_Command(SET_ADVANCED_PROGRAM_CONTROL1); //Set Advanced Program Control:-0.11%/?, PA,WA,CA disable
	LCD_Command(DISPLAY_ON);					// Display on
}

void select_page(unsigned char page)
{
	unsigned char page_cmd_address;
	page_cmd_address = (CMD_PAGE | page); //Set page address
	LCD_Command(page_cmd_address);
}

void select_column(unsigned char column)
{
	unsigned char column_cmd_address_MSB;
	unsigned char column_cmd_address_LSB;
	column_cmd_address_LSB = (CMD_COL_LSB | (column & 0x0F)); //Set column LSB address
	column_cmd_address_MSB = (CMD_COL_MSB | (column >> 4));   //Set column MSB address
	LCD_Command(column_cmd_address_LSB);
	LCD_Command(column_cmd_address_MSB);
}

void LCD_Clear_LOW(void)
{
	unsigned char page, column;
	for (page = 0; page < MAX_PAGES; page++)
	{
		for (column = COL_OFFSET; column < MAX_COLUMNS; column++)
		{
			select_page(page);
			select_column(column);
			LCD_Data(LOW);
			byte buffer_col = column - COL_OFFSET;
			frame_buffer[buffer_col][page] = LOW; //initial
		}
	}
}

void pin_init(void)
{
	LCD_CS_SET(LOW);
	LCD_CS_DIR(OUT);
	LCD_RST_SET(LOW);
	LCD_RST_DIR(OUT);
	LCD_CD_SET(LOW);
	LCD_CD_DIR(OUT);

	MOSI_SET(LOW);
	MOSI_DIR(OUT);
	MISO_SET(LOW);
	MISO_DIR(IN);
	SCK_SET(LOW);
	SCK_DIR(OUT);

	PB4_DIR(OUT);  //Set SS output,which is a general output pin
	MOSI_DIR(OUT); //Set MOSI output
	SCK_DIR(OUT);  //Set SCK output

	LCD_CD_DIR(OUT); //Set CD output
	LCD_CS_DIR(OUT); //Set CS output

	LCD_RST_DIR(OUT); //Set RST output
	LCD_RST(HIGH);	//Set RST disable
}

void test_pix_on(void)
{
	byte init_col = 33;
	byte init_page = 2;
	byte init_pixel = 0;
	init_pixel = _BV(init_pixel) | _BV(init_pixel + 1) | _BV(init_pixel + 2);

	select_page(init_page);
	select_column(init_col);
	LCD_Data(HIGH);
}

void test_pix_off(void)
{
	byte init_col = 33;
	byte init_page = 2;
	byte init_pixel = 0;
	init_pixel = _BV(init_pixel) | _BV(init_pixel + 1) | _BV(init_pixel + 2);

	select_page(init_page);
	select_column(init_col);
	LCD_Data(LOW);
}

//PD2 is my button INTR input, therefore INT0
void Interrupt_Init(void)
{
	//PD2 as input port
	INTERRUPT_DIR(IN);

	cli();//clear interrupt
/*
	Page 68
	MCU Control Register - MCUCR
	Bit 1, 0 - ISC01, ISC00: Interrupt Sense Control 0 Bit 1 and Bit 0
		11	The rising edge of INT0 generates an interrupt request.
*/
	MCUCR = _BV(ISC01) | _BV(ISC00);
	/*
	Page 48
	General Interrupt Control Register - GICR
	Bit 6 - INT0: External Interrupt Request 0 Enable
*/
	GICR = _BV(INT0);

	//Gneral Interrupt Flag Register
	GIFR |= _BV(INTF0);//set flag for INT0

	sei();

}

//kind pf given in lecture already
//This function takes argument of row: actual row number of the pixel
//and column, the column number, 
void Etch_Sketch(unsigned char row, unsigned char column)
{	
	//to limit the col number in range
	if (column > MAX_COLUMNS)
		column = MAX_COLUMNS - 1; 
	//algorithm for calculation where the pixel at on a page(D0~D7)
	unsigned char page = row / MAX_PAGES;  //Set page
	unsigned char pixel = row % MAX_PAGES; //Set pixel
	
	//Limit page num in range
	if (page > MAX_PAGES)
		page = MAX_PAGES - 1; 

	select_page(page);
	select_column(column);
	//there is an offset of 30 to the actual pixel location to the location on LCD
	byte buffer_col = column - COL_OFFSET;
	//do nothing if the pixel exist in the buffer
	pixel = (_BV(pixel) | (frame_buffer[buffer_col][page]));
	//update buffer
	frame_buffer[buffer_col][page] = pixel;
	//write pixel to the screen using SPI transmit funcs
	LCD_Data(pixel);
	_delay_ms(100);
}

//weird problem has been encoutered using 5V input before
//this function is to make sure when it doesnt work I can delete this
//functionality anytime
void UP_BUT_NOT_FUNCTIONING(void)
{
	if (UP_BUTTON && ROWS > MIN_ROWS) //get device status
	{
		BAT_LOW_LED(ON);
		Etch_Sketch(ROWS--, COLUMNS);
		_delay_ms(100);
	}
	else
	{
		BAT_LOW_LED(OFF);
	}
}
/*
void button_det(void)
{

	UP_BUT_NOT_FUNCTIONING();

	if (DOWN_BUTTON && COLUMNS < MAX_COLUMNS -1) //get device status
	{
		BAT_LOW_LED(ON);
		Etch_Sketch(ROWS++, COLUMNS);
		_delay_ms(100);
	}
	else
	{
		BAT_LOW_LED(OFF);
	}

	PWM();
	if(RIGHT_BUTTON && COLUMNS<MAX_COLUMNS-1)  
		{	
			BAT_LOW_LED(ON);
			Etch_Sketch(ROWS, COLUMNS++);
 			_delay_ms(100);
		}
			else
	{
		BAT_LOW_LED(OFF);
	}

	if(LEFT_BUTTON && COLUMNS>MIN_ROWS)  

		{	
		BAT_LOW_LED(ON);
			Etch_Sketch(ROWS, COLUMNS--);
 			_delay_ms(100);
		} 	
					else
	{
		BAT_LOW_LED(OFF);
	}


	if (B_BUTTON) //get device status
	{
		BAT_LOW_LED(ON);
	}
	else
	{
		BAT_LOW_LED(OFF);
	}
}*/

//invoke system ISR, check the INT0_vect
ISR(INT0_vect) 
{

	if (RIGHT_BUTTON && (COLUMNS - COL_OFFSET) < MAX_COLUMNS - 1)
	{
		Etch_Sketch(ROWS, COLUMNS++);
		_delay_ms(100);
	}

	if (LEFT_BUTTON && (COLUMNS - COL_OFFSET) > MIN_ROWS)
	{
		Etch_Sketch(ROWS, COLUMNS--);
		_delay_ms(100);
	}

	if (UP_BUTTON && ROWS > MIN_ROWS)
	{
		Etch_Sketch(ROWS--, COLUMNS);
		_delay_ms(100);
	}

	if (DOWN_BUTTON && ROWS < MAX_ROWS - 1)
	{
		Etch_Sketch(ROWS++, COLUMNS);
		_delay_ms(100);
	}
	//A button for PWN screen bl brightness update
	PWM_INTR();
	
}

//This function initialise the AREF port on MCU
int ADC_READ(void) //with init
{
	ADMUX = _BV(REFS0);
	/*
		P 217
		ADC Multiplexer Selection Register - ADMUX
	
		Bit 7:6 - REFS1:0: Analog Channel and Gain Selection Bits

		Bits 4:0 - MUX4:0: Single Ended Input
			00000	ADC0 Channel 0
	*/
	ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1) ;//
	/*
		ADCSRA	ADC Control and Status Register A
		ADEN	ADC Enable
		ADPS2 : prescaler of 64
		ADPS1 : frequency division of 64
	*/
	//ADC start conversion 
	ADCSRA |= _BV(ADSC);
	//Wait AD transformation finishes
	while (!(ADCSRA & _BV(ADSC))); 
	//return byte value from ADC
	return (ADC);
}

//This function initialise the RAM related pins
void RAM_init(void)
{	
	RAM_CS_DIR(OUT);
	RAM_HOLD_DIR(OUT);
	RAM_WP_DIR(OUT);
	RAM_HOLD(HIGH);
	RAM_WP(HIGH);
}
//this function writes 
void RAM_write(byte bData)
{	
/* P6 of FRAM
	Set write enable latch: WREN
*/
	RAM_CS(LOW);

	SPI_Transmit(WREN); 
	RAM_CS(HIGH);

	RAM_CS(LOW);
	SPI_Transmit(WRITE);
	SPI_Transmit(0x00);// MSBs of address (0~0x07)
	SPI_Transmit(0x00);// LSBs of address(0~0xFF)
	SPI_Transmit(bData);
	RAM_CS(HIGH); //CHIP DESELECT
}

byte RAM_read(void)
{
	RAM_CS(LOW);
	SPI_Transmit(READ);

	SPI_Transmit(0x00);//address MSB
	SPI_Transmit(0x00);//address LSB

	//or just send 0xFF to the mem, it will
	//send back a value
	byte bData = SPI_Transmit(0xFF);
	// SPDR;
	RAM_CS(HIGH); //CHIP DESELECT
	return bData;
}

void Timer_interrupt_init(void)
{
/*
	P 115
	Timer/Counter Interrupt Mask Register - TIMSK
	TOIE1: Timer/Counter1, Overflow Interrupt Enable
	(interrupts globally enabled), the Timer/Counter1 Overflow Interrupt is enabled. 
	The corresponding Interrupt Vec is TIMER1_OVF_vect
*/
	TIMSK = _BV(TOIE1);
/*
	Page 113
	Timer/Counter1 Control Register B - TCCR1B
	Bit 2:0 - CS12:0: Clock Select
	101	clkI/O/1024 (From prescaler)
*/

	TCCR1B = _BV(CS12) | _BV(CS10);

	TCNT1 = 50000;
	//57723
}

//Timer ISR blink few pix
ISR(TIMER1_OVF_vect)
{
	test_pix_on();
	_delay_ms(200);
	test_pix_off();
	TCNT1 = 50000;
}

int main(void)
{

	pin_init();
	SPI_Init();
	button_init(); //initialise the buttons and pull up
	PWN_init();
	LCD_BACKLIGHT_DIR(OUT);
	LCD_BACKLIGHT(OFF);

	BAT_LOW_LED_DIR(OUT);
	BAT_LOW_LED(ON);
	LCD_BACKLIGHT(ON);

	LCD_Init();
	LCD_Clear_LOW();
	Interrupt_Init();

	_delay_ms(32);
	RAM_init();
	_delay_ms(32);

	Timer_interrupt_init();

	RAM_write(60);
	_delay_ms(32);

	COLUMNS =  RAM_read();
	_delay_ms(32);
	BAT_LOW_LED(OFF);

	int ADC_BATT_V = ADC_READ();

	while (TRUE)
	{

		if (ADC_BATT_V < 440)
		{
			BAT_LOW_LED(ON);
		}
		else
		{
			BAT_LOW_LED(OFF);
		}
		//RAM_write(COLUMNS);

		//RAM_write(OCR0);

		//button_det();
	}
}
